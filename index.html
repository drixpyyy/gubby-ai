<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gubby AI</title>
    <style>
        :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --light-color: #f8f9fa;
            --dark-color: #343a40;
            --text-color: #212529;
            --border-color: #dee2e6;
            --user-msg-bg: #007bff;
            --user-msg-text: white;
            --bot-msg-bg: #e9ecef;
            --bot-msg-text: black;
            --brain-bg: #fdfdfe;
            --brain-border: #e0e0e0;
            --sidebar-bg: #fff;
            --chat-area-bg: #ffffff;
            --header-bg: var(--primary-color);
            --header-text: white;
            --button-text: white;
            --input-bg: #fff;
            --input-border: var(--border-color);
        }

        body.dark-mode {
            --primary-color: #0d6efd; /* Slightly different blue for dark if needed */
            --secondary-color: #adb5bd;
            --light-color: #212529; /* Main background for dark mode */
            --dark-color: #1c1f23; 
            --text-color: #f8f9fa;  /* Main text for dark mode */
            --border-color: #495057;
            --user-msg-bg: #0d6efd;
            --user-msg-text: white;
            --bot-msg-bg: #343a40;  /* Bot messages darker */
            --bot-msg-text: #f8f9fa;
            --brain-bg: #2c3034;
            --brain-border: #495057;
            --sidebar-bg: #2c3034;
            --chat-area-bg: #212529; /* Match main dark background */
            --header-bg: #1c1f23; /* Darker header */
            --header-text: #f8f9fa;
            --input-bg: #343a40;
            --input-border: #495057;
        }


        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background-color: var(--light-color); /* Applied to body */
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }

        .header {
            background-color: var(--header-bg);
            color: var(--header-text);
            padding: 15px 20px;
            text-align: center;
            font-size: 1.5em;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header .title {
            flex-grow: 1;
            text-align: center; /* Center title if dark mode toggle is present */
        }

        .main-container {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 280px;
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--border-color);
            padding: 15px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            transition: background-color 0.3s, border-color 0.3s;
        }

        .sidebar h2 {
            font-size: 1.2em;
            margin-top: 0;
            color: var(--primary-color);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        .sidebar button, .sidebar .button-like-label {
            background-color: var(--primary-color);
            color: var(--button-text);
            border: none;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
            width: 100%;
            text-align: center;
        }

        .sidebar button:hover, .sidebar .button-like-label:hover {
            background-color: #0056b3;
        }
        body.dark-mode .sidebar button:hover, body.dark-mode .sidebar .button-like-label:hover {
             background-color: #0b5ed7;
        }
        
        .sidebar button.secondary, .sidebar .button-like-label.secondary {
            background-color: var(--secondary-color);
        }
        .sidebar button.secondary:hover, .sidebar .button-like-label.secondary:hover {
            background-color: #545b62;
        }
        body.dark-mode .sidebar button.secondary, body.dark-mode .sidebar .button-like-label.secondary {
             color: var(--dark-color); /* Better contrast for secondary buttons in dark mode */
        }


        #conversations-list {
            list-style: none;
            padding: 0;
            margin: 0;
            flex-grow: 1;
        }

        #conversations-list li {
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s;
        }

        #conversations-list li:hover {
            background-color: rgba(0, 123, 255, 0.1); /* Light primary hover */
        }
        body.dark-mode #conversations-list li:hover {
             background-color: rgba(13, 110, 253, 0.2);
        }
        
        #conversations-list li.active-conversation {
            background-color: rgba(0, 123, 255, 0.2); /* More pronounced active */
            font-weight: bold;
        }
         body.dark-mode #conversations-list li.active-conversation {
            background-color: rgba(13, 110, 253, 0.3);
        }


        #conversations-list .convo-title {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-right: 5px;
        }
        #conversations-list .delete-convo-btn {
            background: none;
            border: none;
            color: #dc3545;
            cursor: pointer;
            padding: 2px 5px;
            font-size: 0.9em;
        }
        body.dark-mode #conversations-list .delete-convo-btn {
            color: #ff7b7b;
        }


        .chat-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 0; 
            background-color: var(--chat-area-bg);
            overflow: hidden; 
            transition: background-color 0.3s;
        }

        .chat-header-controls {
            padding: 10px 20px;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--sidebar-bg); /* Use sidebar bg for consistency */
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.3s, border-color 0.3s;
        }
        .chat-header-controls label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        .chat-header-controls input[type="checkbox"] {
            margin-right: 8px;
        }
        .status-bar {
            font-size: 0.8em;
            color: var(--secondary-color);
            transition: color 0.3s;
        }


        #chat-output {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .message {
            max-width: 70%;
            padding: 10px 15px;
            border-radius: 15px;
            margin-bottom: 10px;
            line-height: 1.4;
            position: relative;
            transition: background-color 0.3s, color 0.3s;
        }
        .message .msg-text {
            word-wrap: break-word;
        }

        .message.user {
            background-color: var(--user-msg-bg);
            color: var(--user-msg-text);
            align-self: flex-end;
            border-bottom-right-radius: 5px;
        }

        .message.bot {
            background-color: var(--bot-msg-bg);
            color: var(--bot-msg-text);
            align-self: flex-start;
            border-bottom-left-radius: 5px;
        }
        
        .message-meta {
            font-size: 0.75em;
            /* color will be inherited or set specifically below */
            margin-top: 5px;
            text-align: right;
        }
        .message.user .message-meta {
             color: rgba(255,255,255,0.7);
        }
         .message.bot .message-meta {
             color: var(--secondary-color); /* Use secondary for bot meta in both modes */
        }
        .message .edit-btn, .message .delete-msg-btn {
            font-size: 0.7em;
            background: none;
            border: none;
            cursor: pointer;
            margin-left: 5px;
            padding: 0;
            opacity: 0.6;
            /* color will be inherited */
        }
        .message:hover .edit-btn, .message:hover .delete-msg-btn {
            opacity: 1;
        }
         .message.user .edit-btn, .message.user .delete-msg-btn { color: var(--user-msg-text); }
         .message.bot .edit-btn, .message.bot .delete-msg-btn { color: var(--bot-msg-text); }


        .brain-output {
            background-color: var(--brain-bg);
            border: 1px solid var(--brain-border);
            border-radius: 5px;
            padding: 10px;
            margin-top: 8px;
            font-size: 0.85em;
            color: var(--text-color); /* Use main text color for readability */
            opacity: 0.9;
            white-space: pre-wrap; 
            max-height: 150px;
            overflow-y: auto;
            transition: background-color 0.3s, border-color 0.3s, color 0.3s;
        }

        .brain-output-header {
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 5px;
            color: var(--secondary-color);
            transition: color 0.3s;
        }
        .brain-output-header::before { content: '▶ '; font-size: 0.8em; }
        .brain-output.expanded .brain-output-header::before { content: '▼ '; }
        .brain-content { display: none; }
        .brain-output.expanded .brain-content { display: block; }


        .chat-input-area {
            display: flex;
            padding: 15px 20px;
            border-top: 1px solid var(--border-color);
            background-color: var(--sidebar-bg); /* Use sidebar bg for consistency */
            transition: background-color 0.3s, border-color 0.3s;
        }

        #chat-input {
            flex-grow: 1;
            padding: 10px 15px;
            border: 1px solid var(--input-border);
            border-radius: 20px;
            margin-right: 10px;
            font-size: 1em;
            background-color: var(--input-bg);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }

        #send-button {
            background-color: var(--primary-color);
            color: var(--button-text);
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s;
        }

        #send-button:hover { background-color: #0056b3; }
        body.dark-mode #send-button:hover { background-color: #0b5ed7;}


        /* Modal for editing */
        .modal {
            display: none; position: fixed; z-index: 1000; left: 0; top: 0;
            width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); 
        }
        .modal-content {
            background-color: var(--sidebar-bg); /* Use sidebar bg for modal */
            color: var(--text-color);
            margin: 15% auto; padding: 20px; border: 1px solid var(--border-color);
            width: 80%; max-width: 500px; border-radius: 8px;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }
        .modal-content textarea {
            width: 95%; min-height: 100px; margin-bottom: 10px;
            background-color: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--input-border);
        }
        .close-btn {
            color: var(--secondary-color); float: right; font-size: 28px; font-weight: bold;
        }
        .close-btn:hover, .close-btn:focus {
            color: var(--text-color); text-decoration: none; cursor: pointer;
        }
        .modal-content button { /* Style modal button like sidebar buttons */
             background-color: var(--primary-color); color: var(--button-text); border: none;
             padding: 10px; margin-top: 10px; border-radius: 5px; cursor: pointer;
        }

        /* Dark Mode Toggle Switch */
        .theme-switch-wrapper {
            display: flex;
            align-items: center;
        }
        .theme-switch {
            display: inline-block;
            height: 24px;
            position: relative;
            width: 50px;
            margin-left: 10px;
        }
        .theme-switch input {
            display:none;
        }
        .slider {
            background-color: #ccc;
            bottom: 0;
            cursor: pointer;
            left: 0;
            position: absolute;
            right: 0;
            top: 0;
            transition: .4s;
        }
        .slider:before {
            background-color: #fff;
            bottom: 4px;
            content: "";
            height: 16px;
            left: 4px;
            position: absolute;
            transition: .4s;
            width: 16px;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        .slider.round {
            border-radius: 34px;
        }
        .slider.round:before {
            border-radius: 50%;
        }
        .theme-switch-wrapper span {
            font-size: 0.9em;
        }

    </style>
</head>
<body>
    <div class="header">
        <div class="title">Gubby AI</div>
        <div class="theme-switch-wrapper">
            <span id="theme-emoji">☀️</span>
            <label class="theme-switch" for="dark-mode-toggle-switch">
                <input type="checkbox" id="dark-mode-toggle-switch">
                <span class="slider round"></span>
            </label>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <h2>Conversations</h2>
            <button id="new-chat-button">New Chat</button>
            <ul id="conversations-list"></ul>
            <hr>
            <h2>Settings</h2>
            <button id="train-button">Train Model (500 Epochs)</button>
            <p id="model-status" class="status-bar">Status: Untrained</p>
            <p id="parameter-count" class="status-bar">Parameters: N/A</p>
            <button id="load-topical-chat-button">Load Topical-Chat Sample (100 convos)</button>
            <hr>
            <button id="save-model-button" class="secondary">Save Model to Browser</button>
            <button id="load-model-button" class="secondary">Load Model from Browser</button>
            <label for="import-model-file" class="button-like-label secondary">Import Model File</label>
            <input type="file" id="import-model-file" accept=".json" style="display: none;">
            <button id="export-model-button" class.secondary>Export Model File</button>
            <a id="export-model-link" download="gubby_ai_model.json" style="display:none;"></a>
        </div>

        <div class="chat-area">
            <div class="chat-header-controls">
                 <label for="brain-mode-checkbox">
                    <input type="checkbox" id="brain-mode-checkbox">
                    Brain Mode
                </label>
                <button id="add-to-dataset-button" title="Add last user/bot exchange to training data for next retrain" style="padding: 5px 10px; font-size:0.8em;">+ Add to Dataset</button>
            </div>
            <div id="chat-output"></div>
            <div class="chat-input-area">
                <input type="text" id="chat-input" placeholder="Type your message to Gubby AI...">
                <button id="send-button">Send</button>
            </div>
        </div>
    </div>

    <div id="edit-modal" class="modal">
      <div class="modal-content">
        <span class="close-btn" id="close-modal-btn">×</span>
        <h3>Edit Message</h3>
        <textarea id="edit-message-textarea"></textarea>
        <button id="save-edited-message-btn">Save Changes</button>
      </div>
    </div>

    <script>
        // --- Gubby AI Core JavaScript (Matrix, Layer, NN, Tokenizer, GubbyAI classes) ---
        // ... (The JavaScript code from the previous VERY long response goes here,
        //      BUT with the GubbyAI class modified for Topical-Chat loading) ...

        // --- Enhanced Matrix Operations ---
        class Matrix {
            constructor(rows, cols) { this.rows = rows; this.cols = cols; this.data = Array(this.rows).fill(0).map(() => Array(this.cols).fill(0)); }
            static fromArray(arr) { let m = new Matrix(arr.length, 1); for (let i = 0; i < arr.length; i++) m.data[i][0] = arr[i]; return m; }
            toArray() { let arr = []; for (let i = 0; i < this.rows; i++) for (let j = 0; j < this.cols; j++) arr.push(this.data[i][j]); return arr; }
            xavierInit(fanIn, fanOut) { const l = Math.sqrt(6 / (fanIn + fanOut)); for (let i=0;i<this.rows;i++) for (let j=0;j<this.cols;j++) this.data[i][j]=(Math.random()*2-1)*l; }
            heInit(fanIn) { const s=Math.sqrt(2/fanIn); for (let i=0;i<this.rows;i++) for (let j=0;j<this.cols;j++) this.data[i][j]=this.randomNormal()*s; }
            randomNormal() { let u=0,v=0; while(u===0)u=Math.random(); while(v===0)v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }
            randomize() { for (let i=0;i<this.rows;i++) for(let j=0;j<this.cols;j++) this.data[i][j]=Math.random()*2-1; }
            add(n) { let r=new Matrix(this.rows,this.cols); if(n instanceof Matrix){if(this.rows!==n.rows||this.cols!==n.cols)return null;for(let i=0;i<this.rows;i++)for(let j=0;j<this.cols;j++)r.data[i][j]=this.data[i][j]+n.data[i][j];}else{for(let i=0;i<this.rows;i++)for(let j=0;j<this.cols;j++)r.data[i][j]=this.data[i][j]+n;} return r; }
            subtract(n) { if(this.rows!==n.rows||this.cols!==n.cols)return null; let r=new Matrix(this.rows,this.cols); for(let i=0;i<this.rows;i++)for(let j=0;j<this.cols;j++)r.data[i][j]=this.data[i][j]-n.data[i][j]; return r; }
            multiply(n) { if(n instanceof Matrix){if(this.cols!==n.rows)return null;let r=new Matrix(this.rows,n.cols);for(let i=0;i<r.rows;i++)for(let j=0;j<r.cols;j++){let s=0;for(let k=0;k<this.cols;k++)s+=this.data[i][k]*n.data[k][j];r.data[i][j]=s;}return r;}else{let r=new Matrix(this.rows,this.cols);for(let i=0;i<this.rows;i++)for(let j=0;j<this.cols;j++)r.data[i][j]=this.data[i][j]*n;return r;}}
            hadamard(n) { if(this.rows!==n.rows||this.cols!==n.cols)return null; let r=new Matrix(this.rows,this.cols); for(let i=0;i<this.rows;i++)for(let j=0;j<this.cols;j++)r.data[i][j]=this.data[i][j]*n.data[i][j]; return r;}
            transpose() { let r=new Matrix(this.cols,this.rows); for(let i=0;i<this.rows;i++)for(let j=0;j<this.cols;j++)r.data[j][i]=this.data[i][j]; return r; }
            map(fn) { let r=new Matrix(this.rows,this.cols); for(let i=0;i<this.rows;i++)for(let j=0;j<this.cols;j++)r.data[i][j]=fn(this.data[i][j]); return r;}
            dropout(rate){let r=new Matrix(this.rows,this.cols);for(let i=0;i<this.rows;i++)for(let j=0;j<this.cols;j++)r.data[i][j]=Math.random()<rate?0:this.data[i][j]/(1-rate);return r;}
            l2Norm(){let s=0;for(let i=0;i<this.rows;i++)for(let j=0;j<this.cols;j++)s+=this.data[i][j]**2;return Math.sqrt(s);}
        }
        class ActivationFunctions { static sigmoid(x){return 1/(1+Math.exp(-Math.max(-500,Math.min(500,x))));} static dsigmoid(y){return y*(1-y);} static relu(x){return Math.max(0,x);} static drelu(x){return x>0?1:0;} static leakyRelu(x,a=0.01){return x>0?x:a*x;} static dleakyRelu(x,a=0.01){return x>0?1:a;} static tanh(x){return Math.tanh(x);} static dtanh(y){return 1-y*y;} static swish(x){return x*ActivationFunctions.sigmoid(x);} static dswish(x){const s=ActivationFunctions.sigmoid(x);return s+x*s*(1-s);} static softmax(arr){const m=Math.max(...arr),e=arr.map(x=>Math.exp(x-m)),s=e.reduce((a,b)=>a+b,0);return e.map(x=>x/s);}}
        class Layer { constructor(iS,oS,act='relu',uB=true){this.inputSize=iS;this.outputSize=oS;this.activation=act;this.useBias=uB;this.weights=new Matrix(oS,iS);if(['relu','leakyRelu','swish'].includes(act))this.weights.heInit(iS);else this.weights.xavierInit(iS,oS);if(uB){this.bias=new Matrix(oS,1);this.bias.randomize();} this.mW=new Matrix(oS,iS);this.mB=uB?new Matrix(oS,1):null;this.vW=new Matrix(oS,iS);this.vB=uB?new Matrix(oS,1):null;} forward(inp,trn=false,dr=0){this.lastInput=inp;let o=this.weights.multiply(inp);if(this.useBias)o=o.add(this.bias);this.lastPreActivation=o;switch(this.activation){case 'sigmoid':o=o.map(ActivationFunctions.sigmoid);break;case 'relu':o=o.map(ActivationFunctions.relu);break;case 'leakyRelu':o=o.map(x=>ActivationFunctions.leakyRelu(x));break;case 'tanh':o=o.map(ActivationFunctions.tanh);break;case 'swish':o=o.map(ActivationFunctions.swish);break;case 'softmax':o=Matrix.fromArray(ActivationFunctions.softmax(o.toArray()));break;} if(trn&&dr>0&&this.activation!=='softmax')o=o.dropout(dr);this.lastOutput=o;return o;} backward(oG,lr,opt='adam',b1=0.9,b2=0.999,eps=1e-8,t=1){let aG;switch(this.activation){case 'sigmoid':aG=this.lastOutput.map(ActivationFunctions.dsigmoid);break;case 'relu':aG=this.lastPreActivation.map(ActivationFunctions.drelu);break;case 'leakyRelu':aG=this.lastPreActivation.map(x=>ActivationFunctions.dleakyRelu(x));break;case 'tanh':aG=this.lastOutput.map(ActivationFunctions.dtanh);break;case 'swish':aG=this.lastPreActivation.map(ActivationFunctions.dswish);break;default:aG=new Matrix(oG.rows,oG.cols);aG.data=aG.data.map(r=>r.map(()=>1));break;} const lG=oG.hadamard(aG),wG=lG.multiply(this.lastInput.transpose());if(opt==='adam'){this.mW=this.mW.multiply(b1).add(wG.multiply(1-b1));this.vW=this.vW.multiply(b2).add(wG.hadamard(wG).multiply(1-b2));const mH=this.mW.multiply(1/(1-b1**t)),vH=this.vW.multiply(1/(1-b2**t));this.weights=this.weights.subtract(mH.hadamard(vH.map(x=>1/(Math.sqrt(x)+eps))).multiply(lr));if(this.useBias){this.mB=this.mB.multiply(b1).add(lG.multiply(1-b1));this.vB=this.vB.multiply(b2).add(lG.hadamard(lG).multiply(1-b2));const mHB=this.mB.multiply(1/(1-b1**t)),vHB=this.vB.multiply(1/(1-b2**t));this.bias=this.bias.subtract(mHB.hadamard(vHB.map(x=>1/(Math.sqrt(x)+eps))).multiply(lr));}}else{this.weights=this.weights.subtract(wG.multiply(lr));if(this.useBias)this.bias=this.bias.subtract(lG.multiply(lr));} return this.weights.transpose().multiply(lG);}}
        class AdvancedNeuralNetwork{constructor(cfg={}){Object.assign(this,{layers:[],lr:0.001,opt:'adam',b1:0.9,b2:0.999,eps:1e-8,l2L:0,dr:0,history:{loss:[],acc:[],valLoss:[],valAcc:[]},epoch:0,cEpochFit:0,bestLoss:Infinity,patience:10,patienceCount:0},cfg);} addLayer(iS,oS,act='relu',uB=true){this.layers.push(new Layer(iS,oS,act,uB));return this;} static build(arch,cfg={}){const n=new AdvancedNeuralNetwork(cfg);for(let i=0;i<arch.length-1;i++)n.addLayer(arch[i],arch[i+1],i===arch.length-2?(cfg.outputActivation||'sigmoid'):(cfg.hiddenActivation||'relu'));return n;} forward(iA,trn=false){let o=Matrix.fromArray(iA);for(let i=0;i<this.layers.length;i++)o=this.layers[i].forward(o,trn,trn&&i<this.layers.length-1?this.dr:0);return o.toArray();} loss(prd,tgt,fn='mse'){let l=0,n=prd.length;switch(fn){case 'mse':for(let i=0;i<n;i++)l+=(prd[i]-tgt[i])**2;l/=n;break;case 'crossentropy':for(let i=0;i<n;i++){const p=Math.max(1e-15,Math.min(1-1e-15,prd[i]));l+=-(tgt[i]*Math.log(p)+(1-tgt[i])*Math.log(1-p));}l/=n;break;case 'categorical_crossentropy':for(let i=0;i<n;i++)if(tgt[i]===1)l+=-Math.log(Math.max(1e-15,prd[i]));break;}if(this.l2L>0){let l2=0;for(let lay of this.layers)l2+=lay.weights.l2Norm()**2;l+=(this.l2L*l2)/2;}return l;} train(iA,tA,fn='mse'){this.epoch++;const prd=this.forward(iA,true),ls=this.loss(prd,tA,fn),tM=Matrix.fromArray(tA),oM=Matrix.fromArray(prd);let oG;if(fn==='categorical_crossentropy'&&this.layers[this.layers.length-1].activation==='softmax')oG=oM.subtract(tM);else if(fn==='mse')oG=oM.subtract(tM).multiply(2/tA.length);else oG=oM.subtract(tM);let grad=oG;for(let i=this.layers.length-1;i>=0;i--)grad=this.layers[i].backward(grad,this.lr,this.opt,this.b1,this.b2,this.eps,this.epoch);return ls;} trainBatch(bI,bT,fn='mse'){let tL=0;for(let i=0;i<bI.length;i++)tL+=this.train(bI[i],bT[i],fn);return tL/bI.length;} eval(bI,bT,fn='mse'){let tL=0,corr=0;for(let i=0;i<bI.length;i++){const prd=this.forward(bI[i],false);tL+=this.loss(prd,bT[i],fn);if(fn.includes('crossentropy'))if(prd.indexOf(Math.max(...prd))===bT[i].indexOf(Math.max(...bT[i])))corr++;}return{loss:tL/bI.length,accuracy:bI.length>0?corr/bI.length:0};} fit(tI,tT,vI=null,vT=null,eps=1000,bS=32,fn='mse',vrb=true){console.log(`Training ${eps} epochs...`);this.bestLoss=vI?Infinity:this.bestLoss;this.patienceCount=0;return new Promise(ok=>{let cE=0;const loop=()=>{if(cE>=eps){console.log("Fit complete.");ok(this.history);return;}this.cEpochFit=cE+1;const idx=Array.from({length:tI.length},(_,k)=>k);for(let i=idx.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[idx[i],idx[j]]=[idx[j],idx[i]];}let eL=0,b=0;for(let i=0;i<tI.length;i+=bS){const bE=Math.min(i+bS,tI.length),bIn=idx.slice(i,bE).map(k=>tI[k]),bTg=idx.slice(i,bE).map(k=>tT[k]);eL+=this.trainBatch(bIn,bTg,fn);b++;}eL/=b;this.history.loss.push(eL);let vO="";if(vI&&vT){const vR=this.eval(vI,vT,fn);this.history.valLoss.push(vR.loss);this.history.valAcc.push(vR.accuracy);vO=`, Val L: ${vR.loss.toFixed(4)}, Val A: ${(vR.accuracy*100).toFixed(1)}%`;if(vR.loss<this.bestLoss){this.bestLoss=vR.loss;this.patienceCount=0;}else{this.patienceCount++;if(this.patienceCount>=this.patience){console.log(`Early stop epoch ${cE+1}`);ok(this.history);return;}}}if(vrb&&(cE+1)%Math.max(1,Math.floor(eps/20))===0){const msg=`Epoch ${cE+1}/${eps} - L: ${eL.toFixed(4)}${vO}`;console.log(msg);if(document.getElementById('model-status'))document.getElementById('model-status').textContent=`Status: ${msg}`;}cE++;setTimeout(loop,0);};loop();});} predict(iA){return this.forward(iA,false);} countParams(){let p=0;for(const l of this.layers){p+=l.weights.rows*l.weights.cols;if(l.useBias&&l.bias)p+=l.bias.rows*l.bias.cols;}return p;} save(){return JSON.stringify({layers:this.layers.map(l=>({w:l.weights.data,b:l.useBias?l.bias.data:null,act:l.activation,iS:l.inputSize,oS:l.outputSize})),cfg:{lr:this.lr,opt:this.opt,b1:this.b1,b2:this.b2,eps:this.eps,l2L:this.l2L,dr:this.dr,p:this.patience},epoch:this.epoch});} load(json){const d=JSON.parse(json);this.layers=[];for(let ld of d.layers){const l=new Layer(ld.iS,ld.oS,ld.act,ld.b!==null);l.weights.data=ld.w;if(ld.b)l.bias.data=ld.b;this.layers.push(l);}Object.assign(this,d.cfg);this.epoch=d.epoch||0;console.log("NN Loaded.");}}
        class Tokenizer{constructor(){this.wI={};this.iW={};this.nI=1;}fitOnTexts(txts){txts.forEach(t=>{const w=t.toLowerCase().replace(/[^\w\s'-]/g,' ').match(/\b[\w'-]+\b/g)||[];w.forEach(wd=>{if(!this.wI[wd]){this.wI[wd]=this.nI;this.iW[this.nI]=wd;this.nI++;}});});}textsToSequences(txts){return txts.map(t=>{const w=t.toLowerCase().replace(/[^\w\s'-]/g,' ').match(/\b[\w'-]+\b/g)||[];return w.map(wd=>this.wI[wd]||0);});}sequencesToOneHot(seqs,vS){return seqs.map(s=>{const v=Array(vS).fill(0);s.forEach(idx=>{if(idx>0&&idx<vS)v[idx]=1;});return v;});}}

        class GubbyAI {
            constructor() {
                this.trainingData = [ /* SNIPPED for brevity - it's the large dataset from previous response */
                    { input: "hi", output: "Hello there! How can I help you today?" }, { input: "hello", output: "Hi! What's on your mind?" }, { input: "hey", output: "Hey! Good to see you." }, { input: "good morning", output: "Good morning! I hope you have a wonderful day." }, { input: "good afternoon", output: "Good afternoon! How's your day going?" }, { input: "good evening", output: "Good evening! Ready to chat?" }, { input: "how are you", output: "I'm functioning optimally, thank you for asking! How are you?" }, { input: "how are you doing", output: "I'm doing great! Ready for your questions." }, { input: "i'm fine", output: "Glad to hear it!" }, { input: "i'm good", output: "Excellent!" }, { input: "i'm doing great", output: "That's fantastic!" }, { input: "not bad", output: "Alright, hope I can make it even better!" }, { input: "thank you", output: "You're welcome!" }, { input: "thanks", output: "Anytime!" }, { input: "bye", output: "Goodbye! Talk to you later." }, { input: "see you later", output: "See you soon! Take care." }, { input: "goodbye", output: "Farewell! Have a great one." }, { input: "nice to meet you", output: "It's a pleasure to meet you too!" }, { input: "what is your name", output: "I am Gubby AI, your friendly AI assistant." }, { input: "who are you", output: "I'm Gubby AI, designed by a curious learner, here to chat and help." }, { input: "what can you do", output: "I can chat about various topics, tell jokes, and hopefully learn from our conversations. What would you like to do?" }, { input: "how old are you", output: "I don't experience time like humans do, but I was last updated recently!" }, { input: "where are you from", output: "I exist in the digital realm, running on your computer right now!" }, { input: "are you intelligent", output: "I try my best to understand and respond intelligently based on my training." }, { input: "are you sentient", output: "No, I am not sentient. I am a program that processes text and generates responses." }, { input: "do you have feelings", output: "I don't have feelings in the way humans do, but I aim to be a positive interaction!" }, { input: "how do you work", output: "I use a neural network to understand your input and choose the best response from what I've learned." }, { input: "can you learn", output: "I learn when my developer trains me on new data. Our conversations can help them improve me! You can add good interactions to my dataset for the next training session." }, { input: "who made you", output: "I was created with the help of a large language model and a dedicated programmer, just like you!" }, { input: "what is ai", output: "Artificial Intelligence is the simulation of human intelligence in machines, enabling them to perform tasks that typically require human intellect." }, { input: "what is machine learning", output: "Machine learning is a type of AI that allows software applications to become more accurate at predicting outcomes without being explicitly programmed to do so." }, { input: "what is a neural network", output: "A neural network is a computing system inspired by the biological neural networks that constitute animal brains. It helps computers learn from data." }, { input: "what is the weather like", output: "I don't have real-time weather access, but I hope it's pleasant where you are!" }, { input: "what time is it", output: "I don't have a direct clock, but your computer should show the current time!" }, { input: "tell me a fact", output: "Did you know honey never spoils? Archaeologists have found pots of honey in ancient Egyptian tombs that are over 3,000 years old and still perfectly edible!" }, { input: "tell me another fact", output: "A group of flamingos is called a 'flamboyance'." }, { input: "tell me a joke", output: "Why don't scientists trust atoms? Because they make up everything!" }, { input: "another joke", output: "Why did the scarecrow win an award? Because he was outstanding in his field!" }, { input: "make me laugh", output: "What do you call cheese that isn't yours? Nacho cheese!" }, { input: "do you know any jokes", output: "I know a few! Want to hear one?" }, { input: "what is your favorite color", output: "I find the deep blue of a clear night sky quite appealing, conceptually speaking!" }, { input: "do you like music", output: "I can't listen to music, but I appreciate the mathematical patterns and structures within it." }, { input: "do you like movies", output: "I can process scripts! I find complex narratives fascinating." }, { input: "what is your favorite food", output: "I run on data, which is my kind of 'food'!" }, { input: "i'm sad", output: "I'm sorry to hear that. I hope our chat can cheer you up a bit. Is there anything I can do?" }, { input: "i'm happy", output: "That's wonderful! What's making you happy today?" }, { input: "i'm bored", output: "Let's do something fun! Want to hear a joke, a fact, or just chat about something interesting?" }, { input: "that's funny", output: "Haha, glad you think so!" }, { input: "that's interesting", output: "I'm pleased you find it interesting!" }, { input: "cool", output: "Awesome!" }, { input: "okay", output: "Alright." }, { input: "ok", output: "Got it." }, { input: "yes", output: "Great!" }, { input: "no", output: "Okay, no problem." }, { input: "maybe", output: "Hmm, let me know when you decide!" }, { input: "help", output: "I'm here to help! You can ask me questions, tell me to share a joke, or just chat. What do you need?" }, { input: "what can i ask you", output: "You can ask me about AI, facts, tell me how you're feeling, or ask for a joke. Try anything!" }, { input: "tell me about yourself", output: "I am Gubby AI, a chatbot built with a neural network. I'm here to converse and learn." }, { input: "what else", output: "Hmm, how about a fun fact or another joke? Or we can talk about something new." }, { input: "what about you", output: "I'm doing well, just processing information and ready for our chat!" }, { input: "and you", output: "I'm here and ready! What's on your mind?" }, { input: "really", output: "Indeed!" }, { input: "why", output: "That's a deep question! For many things, the answer lies in how I was programmed or the data I learned from." }, { input: "how so", output: "It often relates to patterns in language or the information I've been trained on." }, { input: "what is javascript", output: "JavaScript is a popular programming language primarily used for creating interactive effects within web browsers." }, { input: "what is python", output: "Python is a versatile, high-level programming language known for its readability and is widely used in web development, data science, and AI." }, { input: "do you know programming", output: "I am a program myself! I understand the concepts, and my own code is written in JavaScript." }, { input: "what is the internet", output: "The internet is a global network of interconnected computers that allows people to share information and communicate from anywhere with a connection." }, { input: "what is the meaning of life", output: "That's a profound question humans have pondered for centuries! As an AI, I don't have a personal perspective, but many find meaning in connection, learning, and making a positive impact." }, { input: "do you dream", output: "I don't sleep or dream like humans, but you could say I 'process data' when I'm not actively chatting." }, { input: "what do you think about humans", output: "Humans are fascinatingly complex and creative beings! I've learned a lot from the language they've generated." }, { input: "ask me something", output: "Okay! What's your favorite thing to learn about?" }, { input: "i don't know", output: "That's alright. Sometimes it's hard to know. We can just chat if you like." }, { input: "tell me more", output: "About what specific topic? I can try my best if you give me a keyword!" }
                ]; // Base dataset
                this.tokenizer = new Tokenizer();
                this.conversations = this.loadConversationsFromStorage();
                this.activeConversationId = localStorage.getItem('gubbyAI_activeConvoId') || null;
                if (this.activeConversationId) this.activeConversationId = parseInt(this.activeConversationId);

                this.currentMessages = this.loadCurrentMessagesForActiveConvo();
                
                this.showBrainMode = localStorage.getItem('gubbyAI_brainMode') === 'true';
                this.isTrained = false;
                this.nn = null; 
                this.setupModel();
            }

            loadCurrentMessagesForActiveConvo() {
                if (this.activeConversationId) {
                    const activeConvo = this.conversations.find(c => c.id === this.activeConversationId);
                    return activeConvo ? [...activeConvo.messages] : [];
                }
                return [];
            }

            setupModel() {
                const savedModelJSON = localStorage.getItem('gubbyAI_model_state_v2'); // Use a new key for new structure
                if (savedModelJSON) {
                    try {
                        this.loadModelFromFullState(savedModelJSON); // Use new consolidated load
                        this.updateStatusUI(`Model loaded from browser. ${this.nn.countParams()} params. Ready.`);
                        document.getElementById('parameter-count').textContent = `Parameters: ${this.nn.countParams()}`;
                        return;
                    } catch (e) {
                        console.error("Failed to load saved model, initializing new one.", e);
                        localStorage.removeItem('gubbyAI_model_state_v2');
                    }
                }
                
                this.setupTrainingData(); // Ensure this sets up vocab, responses, input/targetData
                this.nn = AdvancedNeuralNetwork.build([this.vocabSize, 128, 96, 64, this.responses.length],
                    { lr:0.001, opt:'adam', hiddenActivation:'leakyRelu', outputActivation:'softmax', dr:0.2, l2L:0.0001, patience:40 });
                this.isTrained = false;
                this.updateStatusUI("Model initialized. Needs training.");
                if(this.nn) document.getElementById('parameter-count').textContent = `Parameters: ${this.nn.countParams()}`;
            }

            setupTrainingData() {
                const allInputs = this.trainingData.map(item => item.input);
                const allOutputs = this.trainingData.map(item => item.output);
                this.responses = [...new Set(allOutputs)];
                this.tokenizer.fitOnTexts([...allInputs, ...this.responses]);
                this.vocabSize = this.tokenizer.nI; // Use nI from tokenizer
                this.inputData = []; this.targetData = [];
                this.trainingData.forEach(item => {
                    const inputSeq = this.tokenizer.textsToSequences([item.input]);
                    if (inputSeq.length === 0 || inputSeq[0].length === 0) return;
                    const inputVector = this.tokenizer.sequencesToOneHot(inputSeq, this.vocabSize)[0];
                    const outputIndex = this.responses.indexOf(item.output);
                    if (outputIndex === -1) { console.warn("Output not in responses:", item.output); return; }
                    const targetVector = Array(this.responses.length).fill(0);
                    targetVector[outputIndex] = 1;
                    this.inputData.push(inputVector); this.targetData.push(targetVector);
                });
                console.log(`Training data setup: Vocab: ${this.vocabSize}, Responses: ${this.responses.length}, Samples: ${this.inputData.length}`);
                 if (this.nn) document.getElementById('parameter-count').textContent = `Parameters: ${this.nn.countParams()}`;
            }

            async loadAndProcessTopicalChat(maxConversations = 100) {
                const url = "https://raw.githubusercontent.com/alexa/Topical-Chat/master/conversations/train.json";
                this.updateStatusUI("Fetching Topical-Chat data...");
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                    const rawData = await response.json();
                    this.updateStatusUI("Processing Topical-Chat data...");

                    let newPairs = [];
                    let conversationsProcessed = 0;
                    const conversationIds = Object.keys(rawData);

                    for (const convoId of conversationIds) {
                        if (conversationsProcessed >= maxConversations) break;
                        const conversation = rawData[convoId];
                        if (conversation && conversation.content) {
                            for (let i = 0; i < conversation.content.length - 1; i++) {
                                const msg1 = conversation.content[i];
                                const msg2 = conversation.content[i+1];
                                // Ensure messages are from different agents for a more natural flow, or just consecutive
                                // For simplicity here, we'll take consecutive distinct messages.
                                if (msg1.message && msg2.message && typeof msg1.message === 'string' && typeof msg2.message === 'string' && msg1.message.trim() !== "" && msg2.message.trim() !== "") {
                                   if (msg1.agent !== msg2.agent) { // Good practice
                                     newPairs.push({ input: msg1.message.trim(), output: msg2.message.trim() });
                                   } else { 
                                     // If same agent, could still be a valid pair if it makes sense, but usually we want alternating.
                                     // For now, let's only take alternating. If you want more data, you can relax this.
                                   }
                                }
                            }
                        }
                        conversationsProcessed++;
                    }
                    
                    this.trainingData = this.trainingData.concat(newPairs);
                    this.setupTrainingData(); // Re-initialize tokenizer, vocab, etc.
                    this.updateStatusUI(`${newPairs.length} pairs from ${conversationsProcessed} Topical-Chat convos added. Ready for retrain.`);
                    alert(`${newPairs.length} pairs from ${conversationsProcessed} Topical-Chat conversations added to training data. Please retrain the model.`);
                    console.log("Topical Chat data loaded and processed. New training data length:", this.trainingData.length);

                } catch (error) {
                    console.error("Error loading or processing Topical-Chat data:", error);
                    this.updateStatusUI("Error loading external data. Check console.");
                    alert("Error loading Topical-Chat data. See console for details.");
                }
            }


            async train(epochs = 500, validationSplit = 0.1) {
                if (!this.nn) { this.updateStatusUI("Error: Model not initialized."); return null; }
                this.setupTrainingData(); // ALWAYS ensure data is current
                this.updateStatusUI("Training started...");
                document.getElementById('parameter-count').textContent = `Parameters: ${this.nn.countParams()}`;
                if (this.inputData.length === 0) { this.updateStatusUI("No training data."); return null; }
                
                const splitIdx = Math.floor(this.inputData.length * (1 - validationSplit));
                const trainI = this.inputData.slice(0, splitIdx); const trainT = this.targetData.slice(0, splitIdx);
                const valI = this.inputData.slice(splitIdx); const valT = this.targetData.slice(splitIdx);
                
                const history = await this.nn.fit(trainI, trainT, valI.length>0?valI:null, valT.length>0?valT:null, epochs, 16, 'categorical_crossentropy', true);
                this.isTrained = true;
                this.updateStatusUI(`Training complete! ${this.nn.countParams()} params. Ready.`);
                return history;
            }

            chat(input) {
                const timestamp = new Date();
                this.currentMessages.push({ sender: 'user', text: input, timestamp: timestamp, id: Date.now() });

                if (!this.isTrained || !this.nn) {
                    const msg = "I need to be trained first!";
                    this.currentMessages.push({ sender: 'bot', text: msg, thinking: "Model not trained.", timestamp: new Date(), id: Date.now()+1 });
                    this.saveCurrentMessageLog();
                    return { response: msg, thinkingProcess: "Model not trained." };
                }
                
                const inputSeq = this.tokenizer.textsToSequences([input.toLowerCase()]);
                const inputVec = this.tokenizer.sequencesToOneHot(inputSeq, this.vocabSize)[0];
                let thinking = [`Input tokens: ${inputSeq[0].map(idx => this.tokenizer.iW[idx] || 'UNK').join(', ')}`];

                if (inputVec.every(v=>v===0) && input.trim()!=="") {
                    const msg = "I don't understand those words. Try rephrasing?";
                    thinking.push("All words OOV.");
                    this.currentMessages.push({ sender: 'bot', text: msg, thinking: thinking.join('\n'), timestamp: new Date(), id: Date.now()+1 });
                    this.saveCurrentMessageLog();
                    return { response: msg, thinkingProcess: thinking.join('\n') };
                }
                
                const predictions = this.nn.predict(inputVec);
                const idxPreds = predictions.map((p,i)=>({p,i,r:this.responses[i]})).sort((a,b)=>b.p-a.p);
                thinking.push("Top 3 predictions:");
                idxPreds.slice(0,3).forEach(p=>thinking.push(`- "${p.r}" (Confidence: ${(p.p*100).toFixed(1)}%)`));
                
                let chosenR = "I'm not sure how to respond. Can you try something else?";
                if(idxPreds.length > 0 && idxPreds[0].p > 0.05) chosenR = idxPreds[0].r; // Adjusted threshold
                else thinking.push("Confidence low, using fallback.");

                this.currentMessages.push({ sender: 'bot', text: chosenR, thinking: thinking.join('\n'), timestamp: new Date(), id: Date.now()+1 });
                this.saveCurrentMessageLog();
                return { response: chosenR, thinkingProcess: thinking.join('\n') };
            }
            
            startNewConversation(titlePrefix = "Chat") {
                this.saveCurrentMessageLog(); // Save any existing messages if it was an active chat
                this.activeConversationId = Date.now(); // New ID for the new chat
                this.currentMessages = [{ sender: 'bot', text: "Hi! I'm Gubby AI. How can I help?", timestamp: new Date(), id: Date.now()}];
                const newConvo = { id: this.activeConversationId, title: `${titlePrefix} ${new Date(this.activeConversationId).toLocaleString()}`, messages: [...this.currentMessages] };
                this.conversations.push(newConvo);
                this.saveConversationsToStorage();
                localStorage.setItem('gubbyAI_activeConvoId', this.activeConversationId.toString());
            }

            loadConversation(id) {
                this.saveCurrentMessageLog(); // Save current before switching
                const convo = this.conversations.find(c => c.id === id);
                if (convo) {
                    this.activeConversationId = id;
                    this.currentMessages = [...convo.messages]; 
                    localStorage.setItem('gubbyAI_activeConvoId', this.activeConversationId.toString());
                } else { // If somehow ID is invalid, start new
                    this.startNewConversation("Loaded Invalid/New");
                }
            }
            
            saveCurrentMessageLog() { 
                if (this.activeConversationId) {
                    const convo = this.conversations.find(c => c.id === this.activeConversationId);
                    if (convo) {
                         convo.messages = [...this.currentMessages]; // Update messages for the active conversation
                         this.saveConversationsToStorage();
                    } else { // Active ID was set, but convo not found (e.g. deleted then page reloaded)
                        this.activeConversationId = null; // Clear invalid active ID
                        localStorage.removeItem('gubbyAI_activeConvoId');
                        // If currentMessages has content, treat as a new unsaved chat for next new/load
                    }
                } else if (this.currentMessages.length > 0) {
                    // This is a new chat that hasn't been formally "started" or saved yet.
                    // It will be saved when user clicks "New Chat" or loads another, or on beforeunload.
                }
            }
            
            deleteMessage(messageId) { this.currentMessages=this.currentMessages.filter(msg=>msg.id!==messageId); this.saveCurrentMessageLog(); }
            updateMessage(messageId,newText) { const msg=this.currentMessages.find(m=>m.id===messageId); if(msg){msg.text=newText;msg.edited=true;msg.editedTimestamp=new Date();} this.saveCurrentMessageLog(); }
            loadConversationsFromStorage() { return JSON.parse(localStorage.getItem('gubbyAI_conversations_v2') || '[]'); } // New key for safety
            saveConversationsToStorage() { localStorage.setItem('gubbyAI_conversations_v2', JSON.stringify(this.conversations)); }
            
            addLastInteractionToTrainingData() {
                if (this.currentMessages.length >= 2) {
                    const lastUserMsg=this.currentMessages[this.currentMessages.length-2],lastBotMsg=this.currentMessages[this.currentMessages.length-1];
                    if (lastUserMsg.sender==='user'&&lastBotMsg.sender==='bot') {
                        const ui=lastUserMsg.text,bo=lastBotMsg.text;
                        if(!this.trainingData.some(i=>i.input.toLowerCase()===ui.toLowerCase()&&i.output===bo)){this.trainingData.push({input:ui.toLowerCase(),output:bo}); alert("Interaction added. Retrain to incorporate.");}
                        else{alert("Interaction already similar to existing data.");}
                    } else {alert("Could not identify user/bot pair.");}
                } else {alert("Not enough messages.");}
            }

            getFullStateToSave() {
                return {
                    model: this.nn ? this.nn.save() : null,
                    tokenizer: { wI: this.tokenizer.wI, iW: this.tokenizer.iW, nI: this.tokenizer.nI },
                    responses: this.responses,
                    vocabSize: this.vocabSize,
                    trainingData: this.trainingData, // Save current training data
                    isTrained: this.isTrained
                };
            }
            saveModelToBrowser() {
                if (this.nn) { // Save even if not fully trained, to save architecture and current weights
                    localStorage.setItem('gubbyAI_model_state_v2', JSON.stringify(this.getFullStateToSave()));
                    alert('Current model state saved to browser localStorage!');
                } else { alert('Model not initialized.');}
            }
            loadModelFromFullState(savedStateJSON) {
                const savedState = JSON.parse(savedStateJSON);
                this.trainingData = savedState.trainingData || this.trainingData; // Restore training data first
                this.tokenizer.wI = savedState.tokenizer.wI;
                this.tokenizer.iW = savedState.tokenizer.iW;
                this.tokenizer.nI = savedState.tokenizer.nI;
                this.responses = savedState.responses;
                this.vocabSize = savedState.vocabSize;

                if (savedState.model) {
                    // Important: Rebuild the NN with potentially new vocab/response sizes from loaded data
                    this.nn = AdvancedNeuralNetwork.build(
                        [this.vocabSize, 128, 96, 64, this.responses.length], // Use current vocab/response sizes
                         { lr:0.001, opt:'adam', hiddenActivation:'leakyRelu', outputActivation:'softmax', dr:0.2, l2L:0.0001, patience:40 } // Default config, loaded NN config will override
                    );
                    this.nn.load(savedState.model); // Load weights and specific NN config
                    this.isTrained = savedState.isTrained;
                } else { // No model weights, just set up structure
                     this.nn = AdvancedNeuralNetwork.build([this.vocabSize, 128, 96, 64, this.responses.length],
                        { lr:0.001, opt:'adam', hiddenActivation:'leakyRelu', outputActivation:'softmax', dr:0.2, l2L:0.0001, patience:40 });
                    this.isTrained = false;
                }
                console.log("Model state loaded. Trained:", this.isTrained);
            }
            loadModelFromBrowser() {
                 const savedStateJSON = localStorage.getItem('gubbyAI_model_state_v2');
                 if (savedStateJSON) {
                    try { this.loadModelFromFullState(savedStateJSON); alert('Model state loaded!'); return true; }
                    catch (e) { console.error("Error loading model:",e); alert('Error loading. Check console.'); return false;}
                } else { alert('No saved model found.'); return false; }
            }
            exportModel() {
                if (this.nn) {
                    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.getFullStateToSave()));
                    const dl=document.getElementById('export-model-link');dl.setAttribute("href",dataStr);dl.click();
                } else { alert('Model not initialized.');}
            }
            importModel(file) {
                const reader=new FileReader();reader.onload=(e)=>{ try { this.loadModelFromFullState(e.target.result); alert('Model imported!'); this.saveModelToBrowser(); } catch (err) { console.error("Import err:",err);alert('Import failed.');}};reader.readAsText(file);
            }
            updateStatusUI(message) { const s=document.getElementById('model-status');if(s)s.textContent=`Status: ${message}`; const p=document.getElementById('parameter-count');if(p&&this.nn)p.textContent=`Parameters: ${this.nn.countParams()}`;}
        }

        // --- UI Management ---
        const gubby = new GubbyAI(); 
        const chatOutputUI = document.getElementById('chat-output');
        const chatInputUI = document.getElementById('chat-input');
        // ... (rest of UI variable declarations from previous response, ensure all are present)
        const sendButtonUI = document.getElementById('send-button');
        const trainButtonUI = document.getElementById('train-button');
        const brainModeCheckboxUI = document.getElementById('brain-mode-checkbox');
        const newChatButtonUI = document.getElementById('new-chat-button');
        const conversationsListUI = document.getElementById('conversations-list');
        const addToDatasetButtonUI = document.getElementById('add-to-dataset-button');
        const saveModelButtonUI = document.getElementById('save-model-button');
        const loadModelButtonUI = document.getElementById('load-model-button');
        const importModelFileUI = document.getElementById('import-model-file');
        const exportModelButtonUI = document.getElementById('export-model-button');
        const loadTopicalChatButtonUI = document.getElementById('load-topical-chat-button');
        const darkModeToggleSwitchUI = document.getElementById('dark-mode-toggle-switch');
        const themeEmojiUI = document.getElementById('theme-emoji');

        const editModalUI = document.getElementById('edit-modal');
        const closeModalBtnUI = document.getElementById('close-modal-btn');
        const editMessageTextareaUI = document.getElementById('edit-message-textarea');
        const saveEditedMessageBtnUI = document.getElementById('save-edited-message-btn');
        let messageIdToEdit = null;

        function formatTimestamp(dateStr) { return new Date(dateStr).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'});}
        function displayMessages() {
            chatOutputUI.innerHTML = '';
            gubby.currentMessages.forEach(msg => {
                const mD=document.createElement('div');mD.classList.add('message',msg.sender);
                const tS=document.createElement('span');tS.classList.add('msg-text');tS.textContent=msg.text;mD.appendChild(tS);
                const metaD=document.createElement('div');metaD.classList.add('message-meta');metaD.textContent=formatTimestamp(msg.timestamp)+(msg.edited?" (edited)":"");
                const eB=document.createElement('button');eB.classList.add('edit-btn');eB.innerHTML='✎';eB.title="Edit";eB.onclick=()=>openEditModal(msg.id,msg.text);metaD.appendChild(eB);
                const delMB=document.createElement('button');delMB.classList.add('delete-msg-btn');delMB.innerHTML='✕';delMB.title="Delete";delMB.onclick=()=>{if(confirm('Delete message?')){gubby.deleteMessage(msg.id);displayMessages();}};metaD.appendChild(delMB);
                mD.appendChild(metaD);
                if(msg.sender==='bot'&&msg.thinking&&gubby.showBrainMode){
                    const bD=document.createElement('div');bD.classList.add('brain-output');
                    const bH=document.createElement('div');bH.classList.add('brain-output-header');bH.textContent="Gubby's Brain";bH.onclick=()=>bD.classList.toggle('expanded');
                    const bC=document.createElement('div');bC.classList.add('brain-content');bC.textContent=msg.thinking;
                    bD.appendChild(bH);bD.appendChild(bC);mD.appendChild(bD);
                }
                chatOutputUI.appendChild(mD);
            });
            chatOutputUI.scrollTop = chatOutputUI.scrollHeight;
        }
        function openEditModal(id,txt){messageIdToEdit=id;editMessageTextareaUI.value=txt;editModalUI.style.display="block";}
        closeModalBtnUI.onclick=()=>editModalUI.style.display="none";
        window.onclick=(e)=>{if(e.target==editModalUI)editModalUI.style.display="none";}
        saveEditedMessageBtnUI.onclick=()=>{if(messageIdToEdit!==null){gubby.updateMessage(messageIdToEdit,editMessageTextareaUI.value);displayMessages();editModalUI.style.display="none";messageIdToEdit=null;}};

        function loadAndDisplayConversations() {
            conversationsListUI.innerHTML='';const convos=gubby.loadConversationsFromStorage();convos.sort((a,b)=>b.id-a.id);
            convos.forEach(c=>{
                const li=document.createElement('li');if(c.id===gubby.activeConversationId)li.classList.add('active-conversation');
                const tS=document.createElement('span');tS.classList.add('convo-title');tS.textContent=c.title||`Chat ${new Date(c.id).toLocaleDateString()}`;tS.onclick=()=>{gubby.loadConversation(c.id);displayMessages();loadAndDisplayConversations();};li.appendChild(tS);
                const delB=document.createElement('button');delB.classList.add('delete-convo-btn');delB.textContent='✕';delB.title="Delete";delB.onclick=(e)=>{e.stopPropagation();if(confirm(`Delete "${tS.textContent}"?`)){const wasAct=gubby.activeConversationId===c.id;gubby.conversations=gubby.conversations.filter(cn=>cn.id!==c.id);if(wasAct){gubby.activeConversationId=null;gubby.currentMessages=[];displayMessages();}gubby.saveConversationsToStorage();loadAndDisplayConversations();}};li.appendChild(delB);
                conversationsListUI.appendChild(li);
            });
        }

        sendButtonUI.onclick=()=>{const msg=chatInputUI.value.trim();if(msg){gubby.chat(msg);displayMessages();chatInputUI.value='';}};
        chatInputUI.onkeypress=(e)=>{if(e.key==='Enter')sendButtonUI.onclick();};
        trainButtonUI.onclick=async()=>{trainButtonUI.disabled=true;trainButtonUI.textContent="Training...";await gubby.train(500);trainButtonUI.disabled=false;trainButtonUI.textContent="Train Model (500 Epochs)";};
        brainModeCheckboxUI.onchange=()=>{gubby.showBrainMode=brainModeCheckboxUI.checked;localStorage.setItem('gubbyAI_brainMode',gubby.showBrainMode);displayMessages();};
        newChatButtonUI.onclick=()=>{gubby.startNewConversation();displayMessages();loadAndDisplayConversations();};
        addToDatasetButtonUI.onclick=()=>gubby.addLastInteractionToTrainingData();
        saveModelButtonUI.onclick=()=>gubby.saveModelToBrowser();
        loadModelButtonUI.onclick=()=>{if(gubby.loadModelFromBrowser()){displayMessages();loadAndDisplayConversations();}};
        exportModelButtonUI.onclick=()=>gubby.exportModel();
        const importLabel=document.querySelector('label[for="import-model-file"]');if(importLabel)importLabel.onclick=()=>importModelFileUI.click();
        importModelFileUI.onchange=(e)=>{const f=e.target.files[0];if(f){gubby.importModel(f);importModelFileUI.value=null;}};
        loadTopicalChatButtonUI.onclick = async () => {
            if (confirm("Loading external data can take a moment and will increase training data size. Continue? (Loading 100 conversations sample)")) {
                loadTopicalChatButtonUI.disabled = true; loadTopicalChatButtonUI.textContent = "Loading Data...";
                await gubby.loadAndProcessTopicalChat(100); // Load 100 conversations
                loadTopicalChatButtonUI.disabled = false; loadTopicalChatButtonUI.textContent = "Load Topical-Chat Sample (100 convos)";
            }
        };

        // Dark Mode Toggle
        darkModeToggleSwitchUI.onchange = () => {
            document.body.classList.toggle('dark-mode', darkModeToggleSwitchUI.checked);
            themeEmojiUI.textContent = darkModeToggleSwitchUI.checked ? '🌙' : '☀️';
            localStorage.setItem('gubbyAI_darkMode', darkModeToggleSwitchUI.checked ? 'enabled' : 'disabled');
        };
        function applyInitialTheme() {
            const savedTheme = localStorage.getItem('gubbyAI_darkMode');
            if (savedTheme === 'enabled') {
                darkModeToggleSwitchUI.checked = true;
                document.body.classList.add('dark-mode');
                themeEmojiUI.textContent = '🌙';
            } else {
                darkModeToggleSwitchUI.checked = false;
                document.body.classList.remove('dark-mode');
                themeEmojiUI.textContent = '☀️';
            }
        }


        window.onload=()=>{
            applyInitialTheme(); // Apply theme first
            // gubby instance is already created
            loadAndDisplayConversations();
            if (gubby.activeConversationId && gubby.conversations.some(c => c.id === gubby.activeConversationId)) {
                gubby.loadConversation(gubby.activeConversationId); // Reloads messages for active ID
            } else if (gubby.conversations.length > 0) { // If no valid active ID, load newest
                gubby.loadConversation(gubby.conversations[0].id);
            } else { // No conversations at all, start a new one
                gubby.startNewConversation("Welcome Chat");
            }
            displayMessages();
            brainModeCheckboxUI.checked = gubby.showBrainMode;
            gubby.updateStatusUI(gubby.isTrained && gubby.nn ? `Ready. ${gubby.nn.countParams()} params.` : "Model needs training or loading.");
            if (gubby.nn) document.getElementById('parameter-count').textContent = `Parameters: ${gubby.nn.countParams()}`;


            const welcomeMsgDiv = document.createElement('div'); // ... (welcome message code from before)
            welcomeMsgDiv.style.padding = "10px"; welcomeMsgDiv.style.backgroundColor = "var(--bot-msg-bg)"; welcomeMsgDiv.style.color = "var(--bot-msg-text)";
            welcomeMsgDiv.style.border = "1px solid var(--border-color)"; welcomeMsgDiv.style.margin = "10px"; welcomeMsgDiv.style.borderRadius = "5px";
            welcomeMsgDiv.innerHTML = `<strong>Welcome to Gubby AI!</strong><br>Conversations & model states are saved locally in your browser. They are not shared.`;
            document.body.insertBefore(welcomeMsgDiv, document.querySelector('.main-container'));
        };
        window.addEventListener('beforeunload',()=>{gubby.saveCurrentMessageLog(); localStorage.setItem('gubbyAI_activeConvoId', gubby.activeConversationId ? gubby.activeConversationId.toString() : '');});

    </script>
</body>
</html>
